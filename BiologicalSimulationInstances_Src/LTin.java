

import java.awt.Graphics2D;
import java.awt.geom.Ellipse2D;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Random;
import java.util.SortedMap;
import java.util.TreeMap;


import sim.engine.Schedule;
import sim.engine.SimState;
import sim.engine.Steppable;
import sim.engine.Stoppable;
import sim.field.continuous.Continuous2D;
import sim.util.Bag;
import sim.util.Double2D;
import sim.util.IntBag;
import sim.portrayal.*;
import sim_platform.PPatchSim;


/**
 * Class which defines the behaviour and attributes of the LTin Cell.
 * With some common attributes and behaviour shared with the other cell types, this
 * class extends the Cells superclass
 * 
 * @author Kieran Alden
 *
 */
//public class LTin extends Cells
public class LTin extends SimplePortrayal2D implements Steppable,Stoppable
{		
	/**
	 Flag to show if this cell is expressing RET Ligand (chosen by probability by when the cell is created)
	 */
	public boolean expressingRETLigand;
	
	/**
	  Where the agent starts its move from.  Used in tracking cell movement
	 */
	public Double2D agentPreviousLocation;
	
    /**
	 * Stores the speed at which this cell will move. Generated by the constructor
	 */
    public double cellSpeed=0;
    
    /**
     * Holds the correct cell speed which reflects the simulation granularity.  Calculated in the LTin and LTi class constructors
     */
    public double cellSpeedSecond;
    
    /**
	 * Representation of the state this cell is currently in. Used as a reference for cell colour on the display 
	 */
    public int cellState;          // Colour Code - will show cell state
    
    /**
	 * <a name = "ltoDistanceThreshold"></a>
	 * <b>Description:<br></b> 
	 * Distance threshold from an active LTo at which an immature LTo cell can become active
	 * <br><br>
	 * <b>Restrictions:<br></b>
	 * Must be above 0
	 * <br><br>
	 * <b>Units & Representation:<br></b>
	 * Distance in pixels
	 * <br><br>
	 * <b>Link to Domain and Platform Models:</b>
	 */
	public double ltoDistanceThreshold = 1;     
    
    /**
	 * Flag to show if this class has been stopped (when no longer needed)
	 */
    private Stoppable stopper = null;
    
    /**
	 * Method to change the value of the stopper
	 * @param stopper	Whether the class should be stopped or not
	 */
    public void setStopper(Stoppable stopper)   {this.stopper = stopper;}
    
    /**
     * Method to stop the class where necessary
     */
    public void stop(){stopper.stop();}
    
    /**
	 * A Collection with an x and y value detailing the position of the cell
	 */
	public Double2D agentLocation; 
	
	/**
	 * Where the cell started in the tracking hour.  Used to calculate displacement and velocity
	 */
	public Double2D agentTrackStartLocation;
	
	/**
	 * Where the cell ended in the tracking hour.  Used to calculate displacement and velocity
	 */
	public Double2D agentTrackEndLocation;
	
	/**
	 * Flag to show whether the cell has moved off the left or right of the screen and can be stopped
	 */
	public boolean stopped = false;
	
	/**
	 *	Will hold LTo that the cell is in contact with (for easier referencing when looking at signalling etc in next step) 
	 */
    public Object contactedCell = null;
    
    /**
	 * Number of minutes the cell was tracked for
	 */
	public int timeTracked = 0;
	
	/**
	 * How far the cell moved in the tracked hour
	 */
	public double trackLength = 0.0;
	
    public ArrayList<Object> receptors = new ArrayList<Object>();
	
	/**
	 * <a name = "HCELL_DIAMETER"></a>
	 * <b>Description:<br></b> 
	 * Diameter of LTin and LTi Cells (in pixels - 1 pixel = 4 micrometres)
	 * <br><br>
	 * <b>Restrictions:<br></b>
	 * Set as has been verified experimentally
	 * <br><br>
	 * <b>Units & Representation:<br></b>
	 * Pixels
	 * <br><br>
	 * <b>Link to Domain and Platform Models:</b>
	 */
	public static double cell_diameter = 2;
	
	/**
	 * <a name = "stableBindProbability"></a>
	 * <b>Description:<br></b> 
	 * The probability that when two cells come into contact, there will be a stable bind and signalling 
	 * will occur
	 * <br><br>
	 * <b>Restrictions:<br></b>
	 * Must be numeric and above 0, yet less than or equal to 100
	 * <br><br>
	 * <b>Units & Representation:<br></b>
	 * Probability
	 * <br><br>
	 * <b>Link to Domain and Platform Models:</b>
	 */
	public double stableBindProbability = 50;
	
	
    /**
     * Creates a new LTin Agent (or Cell), and assigns the cell a speed.
     * This speed is a random gaussian number between a lower and upper bound set when the simulation is run
     * 
     * @param cellId	Tag used to keep track of the cell by the simulation, will be 'LTin' plus a number	
     * @param location	Double2D Coordinate location of the LTin Cell on the grid
     * @param cellSpeedLowBound	Lower bound used to generate cell speed
     * @param cellSpeedUpBound	Upper bound used to generate cell speed
     */
    public LTin(PPatchSim ppsim,Double2D location,ArrayList<ArrayList<String>> cellReceptors)
	{
    	// Constructor for superclass takes the location & cell tag
		//super(location,sp);
    	
    	this.agentLocation = location;
    
		this.agentPreviousLocation = location;
		
		// Initialise the receptors
    	    	
    	try
    	{
    		for(int i=0;i<cellReceptors.size();i++)
    		{
    			// get the receptor
    			ArrayList<String> receptorDetail = cellReceptors.get(i);
    			
    			Class<?> receptorType = Class.forName(receptorDetail.get(0));
    			Constructor<?> con = receptorType.getConstructor(new Class[]{ArrayList.class});
    			Object receptorObj = con.newInstance(receptorDetail);
    			this.receptors.add(receptorObj);
    			
    			
    		}
    	}
    	catch(Exception e)
    	{
    		e.printStackTrace();
    	}
		
		// generate speed of this cell
		Random rnd = new Random();
		
		// while loop is used to ensure the cellspeed falls within the set range
        while(cellSpeed<ppsim.hemCells.cellSpeedLowBound || cellSpeed>ppsim.hemCells.cellSpeedUpBound)
		{
			cellSpeed = rnd.nextGaussian();
		}
        
        cellSpeedSecond = this.cellSpeed / ppsim.simulationSpec.secondsPerStep;
        
        // set cell colour - all LTin cells in initial state start by being coloured yellow.  On change
        // of state, the colour will change
        this.cellState=4;
	}	
	
    public void setAgentTrackStartLocation()
    {
    	this.agentTrackStartLocation = this.agentLocation;
    }
	
	/* (non-Javadoc)
	 * @see sim.app.ppatch.Cells#getType()
	 */
	public String getType()
    {
        return "LTin";
    }
	
	public void addToSchedule(Schedule sch)
	{
		this.setStopper(sch.scheduleRepeating(this));
	}
	
	public Boolean getexpressingRETLigand()
	{
		return this.expressingRETLigand;
	}
	 
	/* (non-Javadoc)
	 * @see sim.engine.Steppable#step(sim.engine.SimState)
	 */
	public void step(final SimState state)
	{
		PPatchSim ppsim = (PPatchSim)state;
		
		if(ppsim.schedule.getSteps()*ppsim.simulationSpec.secondsPerStep < ((ppsim.simulationSpec.simulationTime*60)*60))
		{
			this.agentPreviousLocation = this.agentLocation;
		
			// check that the cell is still active (has not left the screen)
			if(!this.stopped)
			{
				if(ppsim.simulationSpec.cellTrackingEnabled)
				{
					//if(ppsim.schedule.getSteps()==((60/simParams.secondsPerStep)*(simParams.trackingSnapStartHr*60)))
					if(ppsim.schedule.getSteps()*ppsim.simulationSpec.secondsPerStep == ((ppsim.cellTrackStats.trackingSnapStartHr*60)*60))
					{
						this.agentTrackStartLocation = this.agentLocation;
					}
					//if(ppsim.schedule.getSteps()==((60/simParams.secondsPerStep)*(simParams.trackingSnapEndHr*60)))
					if(ppsim.schedule.getSteps()*ppsim.simulationSpec.secondsPerStep ==((ppsim.cellTrackStats.trackingSnapEndHr*60)*60))
					{
						this.agentTrackEndLocation = this.agentLocation;
					}
				}
				// no attractive force for LTin Cells - need to implement random angle movement
				// If the cell is in a position where it would be held by adhesion factors, this is calculated in the performMove3 method
				
				double angle = Math.toRadians(ppsim.random.nextInt(360)+1);
				// send to function which deals with the move
				this.performMove3(ppsim,angle);					

			}
			else		// the cell has left the right or left of the screen/tract and will be stopped and removed from the simulation
			{
				// REMOVE USING ENVIRONMENT JAVA REFLECTION
				try
				{
					Class<?> environmentClass = ppsim.intestine_env.getClass();
					Method meth = environmentClass.getMethod("remove",new Class[]{Object.class});
					meth.invoke(ppsim.intestine_env,this);
					//ppsim.intestine_env.tract.remove(this);
				}
				catch(Exception e)
				{
					e.printStackTrace();
				}
				
				this.stop();
				
				// decrease the cellularity
				// get the current cellularity for this cell from the map
				
				int cellCount = ppsim.simulatedCellCellularity.get(this.getClass().getName());
				// decrease by one
				cellCount--;
				// remove the count from the map
				ppsim.simulatedCellCellularity.remove(this.getClass().getName());
				// add the new count back in
				ppsim.simulatedCellCellularity.put(this.getClass().getName(),cellCount);
				
				//simParams.lTinCellularity--;
			
				// Remove from all tracking
				if(ppsim.simulationSpec.cellTrackingEnabled)
				{
					if(ppsim.cellTrackStats.trackedCells_Away.contains(this))
						ppsim.cellTrackStats.trackedCells_Away.remove(this);
					if(ppsim.cellTrackStats.trackedCells_Close.contains(this))
						ppsim.cellTrackStats.trackedCells_Close.remove(this);
				}
			}
		}
		else
		{
			// simulation is over so stop the cell
			this.stop();
		}
	}	
	
	
	/**
     * Changes the location of the cell using the cells individual speed and a calculated angle.  Includes dealing with all
     * collision detection and moving the cell on the graphic
     * 
     * @param ppsim	The current simulation state
     * @param angle	The angle (in Radians) to move the cell on the tract
     */
    public void performMove3(PPatchSim ppsim, double angle)
    {
    	double distanceToMove = this.cellSpeed;
		double distanceMoved = 0;
		
		// position to move initialised to the agents current location incase the cellSpeed is zero
		Double2D newPosition = this.agentLocation;
    	
		// Now move the cell while it still has distance to move
		while(distanceToMove>0)
		{	
			try
			{
				// Firstly, check if the cell is in contact with another cell - this will affect the way it moves
				if(this.contactedCell != null)
				{
					// Get the class of the contacted cell
					Class<?> contactedCellClass = this.contactedCell.getClass();
					
					if(contactedCellClass.equals("LTin") || 
							(contactedCellClass.equals("LTi")) || 
							(contactedCellClass.equals("RLNonStromal")))
					//if((this.contactedCell instanceof LTin) || (this.contactedCell instanceof LTi) || (this.contactedCell instanceof RLNonStromal))
					{				
						angle = this.performMoveAfterContact(ppsim,distanceToMove);
					}
					else		// CELL IS AN LTo
					{
						// DETERMINE IF THE LTO CELL EXPRESSES ADHESION FACTORS - DOES THIS BY SEEKING A PARTICULAR METHOD
						 // Set up the receptors for this object
						boolean adhesionExpressed = false;
				        try
				    	{
				        	// Get the expressors from the cell in contact with
				        	
				        	Method getExpressors = contactedCellClass.getMethod("returnExpressors",new Class[]{});
				        	ArrayList<Object> expressors = (ArrayList<Object>)getExpressors.invoke(contactedCell);
				        	
				        	
				        	// Determine if adhesion factors are expressed and act upon these
				        	Object expressor = null;
				        	
				        	for(int i=0;i<expressors.size() & !adhesionExpressed;i++)
				    		{
				        		try
				        		{
				        			// get the receptor
				        			expressor = expressors.get(i);
				    		
				        			Class<?> expressorType = expressors.get(i).getClass();
				        			Method meth = expressorType.getMethod("returnAdhesionExpressionLevel",new Class[]{});
				        			double adhesion = (Double)meth.invoke(expressor);
				        			adhesionExpressed = true;
				        		}
				        		catch(NoSuchMethodException e)
						        {
						        	// Skip over, may be the wrong receptor
						        	//e.printStackTrace();
						        }
				    		}
				    		
				    		if(adhesionExpressed)
				    		{
				    			// check if prolonged contact should take place mediated by VCAM
								// determine effect of VCAM & generate angle to move
				    			
				    			// This should be worked out by the adhesion factor receptor of this cell, if expressed
				    			// So, find the receptor
				    			boolean stuck = false;
				    			boolean receptorFound = false;
				    			
				    			for(int i=0;i<this.receptors.size() && !receptorFound;i++)
				    			{
				    				try
				    				{
				    					Object receptor = this.receptors.get(i);
				    								    				
				    					Method vcamEffect = receptor.getClass().getMethod("examineVCAMEffect",new Class[]{Object.class});
				    					stuck = (Boolean)vcamEffect.invoke(receptor,expressor);
				    					receptorFound=true;
				    				}
				    				catch(NoSuchMethodException e)
							        {
							        	// Skip over, may be the wrong receptor
							        	//e.printStackTrace();
							        }
				    				
				    			}
				    			
				    			if(stuck)
				    			{
				    				distanceToMove = 0;
				    			}
				    			else
				    			{
				    				this.contactedCell = null;
				    	    		
				    	    		double angleToMove = this.avoidCellCollision(ppsim,distanceToMove);
				    	    		newPosition = calculateNewPosition(this.agentLocation,distanceToMove,angleToMove,ppsim);
				    	    		this.agentLocation = newPosition;
				    	    		
				    	    		// SET THE OBJECT LOCATION
				    	    		try
				    	    		{
				    	    			Class<?> environmentClass = ppsim.intestine_env.getClass();
				    	    			Method meth = environmentClass.getMethod("setLocation",new Class[]{Object.class,Double2D.class});
				    	    			meth.invoke(ppsim.intestine_env,this,this.agentLocation);
				    	    			
				    	    			distanceMoved = distanceMoved+distanceToMove;
				    	    			distanceToMove=0;
				    	    		}
				    	    		catch(Exception e)
				    	    		{
				    	    			e.printStackTrace();
				    	    		}
				    			}
				    		}
				    	}
				        
				    	catch(Exception e)
				    	{
				    		e.printStackTrace();
				    	}
					}
				}
				else
				{			
					// do the move, but do in small chunks of 0.1 (makes collision detection along the path easier)
					if(distanceToMove>0.1)
					{
						// calculate the new position
						newPosition = calculateNewPosition(this.agentLocation,0.1,angle,ppsim);
						// reduce the distance moved
						distanceToMove=distanceToMove-0.1;
						distanceMoved=distanceMoved+0.1;
					}
					else
					{
						// This is the final move the cell will make in this step
						newPosition = calculateNewPosition(this.agentLocation,distanceToMove,angle,ppsim);
						distanceToMove=0;
						distanceMoved+=distanceToMove;
					}
			
					this.agentLocation = newPosition;
				
					// NOW check if there are any collisions on this move
						
					// first check if there is a collision with an LTo or Decoy Stromal Cell
					boolean collision = collisionCheck2(ppsim);
				
					if(collision)				// this collision will either be with an active LTo or Decoy - all movement should stop as a bind is assumed
					{
						// ADD TO CELLS BEING TRACKED IF NOT YET IN THERE (WHERE TRACKING IS BASED ON CONTACT)
						if(ppsim.simulationSpec.cellTrackingEnabled)
						{
							if(!ppsim.cellTrackStats.trackedCells_Close.contains(this))
							{
								ppsim.cellTrackStats.trackedCells_Away.remove(this);
								this.trackLength = 0;
								this.timeTracked = 0;
								this.agentTrackStartLocation = this.agentLocation;
								ppsim.cellTrackStats.trackedCells_Close.add(this);
							}
						}
					}
					else
					{
						// Now need to check if there is a collision with an LTi/LTin
						// also deals with checking if cell is a decoy ret ligand
						collision = ltiltinCollision((Continuous2D)ppsim.intestine_env.getClass().getDeclaredField("tract").get(ppsim.intestine_env));
					
						if(collision)
						{
							// check whether the cell this is in contact with expresses RET Ligand
							if(this.contactedCell.getClass().getName().equals("LTin"))
							{
								// Cast the contacted cell to LTin and process 
								LTin ltinCell = (LTin)this.contactedCell;
								
								if(ltinCell.expressingRETLigand)
								{
									// NOW WORK OUT IF THIS CONTACT 'ACTIVATES' THE LIGAND
									// SIMULATES A 'BIND STRENGTH
									// 16/12/10
									// FIRSTLY NEED TO CHECK WHETHER THIS CONTACT CHANGES STATE (BASED ON A PROBABILITY)
									int probability = ppsim.random.nextInt(100)+1;
									
									if(probability<=this.stableBindProbability)	// the cell will bind briefly & not complete the rest of its move
									{
										// NEEDS FURTHER EXAMINATION WHEN ACTIVATED
										//distanceToMove=0;
									}
								}
								else
								{
									// there is a collision that needs to be dealt with but the cell is not expressing RET ligand
									// move the cell away at a random angle
								
									while(collision)
									{
										angle = Math.toRadians(ppsim.random.nextDouble()*360);
										// 	calculate the new position
										newPosition = calculateNewPosition(this.agentLocation,0.1,angle,ppsim);
										this.agentLocation = newPosition;
										collision = ltiltinCollision((Continuous2D)ppsim.intestine_env.getClass().getDeclaredField("tract").get(ppsim.intestine_env));
										
										//collision = ltiltinCollision(ppsim.intestine_env.tract);
									}
									this.contactedCell = null;
								}
								
								
								
								
							}
							else if (this.contactedCell.getClass().getName().equals("LTi"))
							{
								// Cast the contacted cell to LTi and process
								LTi ltiCell = (LTi)this.contactedCell;
								
								if(ltiCell.expressingRETLigand)
								{
									// NOW WORK OUT IF THIS CONTACT 'ACTIVATES' THE LIGAND
									// SIMULATES A 'BIND STRENGTH
									// 16/12/10
									// FIRSTLY NEED TO CHECK WHETHER THIS CONTACT CHANGES STATE (BASED ON A PROBABILITY)
									int probability = ppsim.random.nextInt(100)+1;
									
									if(probability<=this.stableBindProbability)	// the cell will bind briefly & not complete the rest of its move
									{
										// NEEDS FURTHER EXAMINATION WHEN ACTIVATED
										//distanceToMove=0;
									}
								}
								else
								{
									// there is a collision that needs to be dealt with but the cell is not expressing RET ligand
									// move the cell away at a random angle
								
									while(collision)
									{
										angle = Math.toRadians(ppsim.random.nextDouble()*360);
										// 	calculate the new position
										newPosition = calculateNewPosition(this.agentLocation,0.1,angle,ppsim);
										this.agentLocation = newPosition;
										//collision = ltiltinCollision(ppsim.intestine_env.tract);
										collision = ltiltinCollision((Continuous2D)ppsim.intestine_env.getClass().getDeclaredField("tract").get(ppsim.intestine_env));
									}
									this.contactedCell = null;
								}
								
							}
							
							
						}
					}
				}
			}
			catch(Exception e)
			{
				e.printStackTrace();
			}
		}
	
		// set the objects location on the tract
		try
		{
			Class<?> environmentClass = ppsim.intestine_env.getClass();
			Method meth = environmentClass.getMethod("setLocation",new Class[]{Object.class,Double2D.class});
			meth.invoke(ppsim.intestine_env,this,this.agentLocation);
			//ppsim.intestine_env.tract.setObjectLocation(this,this.agentLocation);
		}
		catch(Exception e)
		{
			e.printStackTrace();
		}
		
		
		// update cell tracked length
		if(ppsim.simulationSpec.cellTrackingEnabled)
		{
			if(ppsim.cellTrackStats.trackedCells_Away.contains(this) || ppsim.cellTrackStats.trackedCells_Close.contains(this))
			{
				// only tracking each cell for an hour - do not update if past an hour 
				if(this.timeTracked<(3600/ppsim.simulationSpec.secondsPerStep))
				{
					// the cell is being tracked - need to update the length
					this.trackLength = this.trackLength + distanceMoved;
					this.timeTracked++;
				}
				else if(this.timeTracked == (3600/ppsim.simulationSpec.secondsPerStep))
				{
					// add the end point to work out displacement
					this.agentTrackEndLocation = this.agentLocation;
				}
			
			}
		} 	
    }
    
    /**
     * Used to move a cell away if in contact with an LTin/LTi/RLNS cell which, if RET ligands are enabled could have been in stable contact 
     * with the cell.  As no adhesion factors though, the cell must move away
     * 
     * @param ppsim	The current simulation state
     * @param distanceToMove	The distance the cell is required to move
     * @return	 the angle at which the cell should move away
     */
    public double performMoveAfterContact(PPatchSim ppsim, double distanceToMove)
    {
    	double angleToMove = 0;
    	
    	
	    	// the cell is in contact with another cell
			// need to establish if this is a ret ligand expressing LTin or LTi cell, or a stromal cell
	    	Class<?> contactedCellClass = this.contactedCell.getClass();
			
	    	//if(this.contactedCell instanceof LTin)
			if(contactedCellClass.getName().equals("ppatch_onepatch_cells.LTin"))
	    	{		
				// Cast the contacted cell object to LTin so can process
				Object ltinContactCell = this.contactedCell;
				
				try
		    	{
		    	
					// Find out if this cell is expressing RET ligand
					Method expressingRETLigand = contactedCellClass.getMethod("getexpressingRETLigand",new Class[]{});
					Boolean expressingRET = (Boolean)expressingRETLigand.invoke(ltinContactCell);
					
					
					if(expressingRET)
					{
						// collision was with a decoy - an LTin or LTi cell expressing RET Ligand - this should stick but there should be no
						// prolonged contact - therefore the cell should move away
						angleToMove = Math.toRadians(ppsim.random.nextInt(360)+1);
						this.contactedCell = null;
					
						//return angleToMove;
					}
					else
					{
						angleToMove = this.avoidCellCollision(ppsim,distanceToMove);
						this.contactedCell = null;
						
						//return angleToMove;
					}
		    	}
				catch(Exception e)
				{
					e.printStackTrace();
				}
				
				return angleToMove;
				
			}
				
			else if(contactedCellClass.getName().equals("LTi"))
			{
				Object ltiContactCell = this.contactedCell;
				
				try
		    	{
		    	
					// Find out if this cell is expressing RET ligand
					Method expressingRETLigand = contactedCellClass.getMethod("getexpressingRETLigand",new Class[]{});
					Boolean expressingRET = (Boolean)expressingRETLigand.invoke(ltiContactCell);
					
					
					if(expressingRET)
					{
						// collision was with a decoy - an LTin or LTi cell expressing RET Ligand - this should stick but there should be no
						// prolonged contact - therefore the cell should move away
						angleToMove = Math.toRadians(ppsim.random.nextInt(360)+1);
						this.contactedCell = null;
					
						//return angleToMove;
					}
					else
					{
						angleToMove = this.avoidCellCollision(ppsim,distanceToMove);
						this.contactedCell = null;
						
						//return angleToMove;
					}
		    	}
				catch(Exception e)
				{
					e.printStackTrace();
				}
				
				return angleToMove;	
				
			}
			// Check if the cell is in contact with a Decoy - i.e. a cell not part of the process but has a RET Ligand
			else		// Cell is a RLNonStromal - can't be LTo as checked by if elsewhere 
			{
				angleToMove = this.avoidCellCollision(ppsim,distanceToMove);
				this.contactedCell = null;
				
				return angleToMove;
			}
    
    }
    
    /**
     * Used within the performMove method, this takes a cell, a distance, and an angle, and will work out the cells new position.
     * Will deal with any cases where the cell needs to be rolled around the top/bottom of the screen
     * 
     * @param movingCellLoc	The currrent location of the cell that is moving
     * @param distanceToMove	The distance the cell should move
     * @param angle	The angle at which the cell should move
     * @param ppsim	The current state of the simulation
     * @return	Double2D checkedLoc	The new location of this cell (after checking for roll around requirements)
     */
	public Double2D calculateNewPosition(Double2D movingCellLoc,double distanceToMove, double angle,PPatchSim ppsim)
    {
		double newX,newY;
		newX = (movingCellLoc.x + (distanceToMove * Math.cos(angle)));
		newY = (movingCellLoc.y + (distanceToMove * Math.sin(angle)));
		// check if the location needs to be rolled round the screen
		Double2D checkedLoc = this.rollAround(newX,newY,ppsim);
		
		// return the checked position
		return checkedLoc;	
	}
	
	/**
     * Ensures that if a new coordinate is calculated which will be off the screen, the coordinate is rolled around to the opposite side
     * 
     * @param newX	The x coordinate that has been calculated to be checked
     * @param newY	The y coordinate that has been calculated to be checked
     * @param ppsim	The current state of the simulation
     * @return	Double2D newLoc	The new cell location, whether changed or unchanged
     */
    public Double2D rollAround(Double newX,Double newY,PPatchSim ppsim)
    {
    	try
    	{
	    	double currentGridLength = ppsim.intestine_env.getClass().getDeclaredField("currentGridLength").getDouble(ppsim.intestine_env);
			double currentGridHeight = ppsim.intestine_env.getClass().getDeclaredField("currentGridHeight").getDouble(ppsim.intestine_env);
	    	
	    	if(newY>currentGridHeight)			// roll round so cell appears at top of screen
			{
				newY=0.0;
			}
			else if(newY<0.0)                      // roll round so appears at bottom
			{
				newY=currentGridHeight;
			}
		
	    	if(newX>currentGridLength || newX<0.0)   // if has left right or left, the cell is deemed dead, so stop from the schedule
	    	{
	    		this.stopped = true;
	    	}
    	}
    	catch(Exception e)
    	{
    		e.printStackTrace();
    	}
    	
		Double2D newLoc = new Double2D(newX,newY);
		
		return newLoc;
	}
    
    /**
     * Determines whether a LTin/LTi cell remains in contact with an LTo due to the level of VCAM being expressed by that 
     * cell.  If not the LTin/LTi will move away
     * @param ppsim	The current simulations state
     */
    /*public double calculateVCAMEffect2(PPatchSim ppsim, double distanceToMove)
    {
    	
    	// The previous function already concluded that the contact cell is an LTo, so can cast
    	//LTo ltoCell = (LTo)this.contactedCell;
    	Double2D newPosition;
    	
    	double probability = ppsim.random.nextDouble();
    	
    	boolean stuck = false;
    	
    	try
    	{
	    	
	    	Class<?> cellClass = this.contactedCell.getClass();
			Method vcamEffect = cellClass.getMethod("examineVCAMEffect",new Class[]{Double.class,Double.class,Double.class});
			stuck = (Boolean)vcamEffect.invoke(this.contactedCell,simParams.adhesionFactorExpressionSlope,probability);
    	}
    	catch(Exception e)
    	{
    		e.printStackTrace();
    	}
    	
    	//boolean stuck = ltoCell.vcamAdhesionEffect.examineVCAMEffect(simParams.adhesionFactorExpressionSlope,simParams.maxProbabilityOfAdhesion,probability);
    	
    	if(stuck)
    	{
    		return 0;
    	}
    	else
    	{
    		this.contactedCell = null;
    		
    		double angleToMove = this.avoidCellCollision(ppsim,distanceToMove);
    		newPosition = calculateNewPosition(this.agentLocation,distanceToMove,angleToMove,ppsim);
    		this.agentLocation = newPosition;
    		
    		// SET THE OBJECT LOCATION
    		try
    		{
    			Class<?> environmentClass = ppsim.intestine_env.getClass();
    			Method meth = environmentClass.getMethod("setLocation",new Class[]{Object.class,Double2D.class});
    			meth.invoke(ppsim.intestine_env,this,this.agentLocation);
    		}
    		catch(Exception e)
    		{
    			e.printStackTrace();
    		}
    		
    		//ppsim.intestine_env.tract.setObjectLocation(this,this.agentLocation);
    		return distanceToMove;
    	}
    }	*/
    
    /**
     * Deals with the case where an LTin/LTi cell must move away from a cell it has been in contact with, 
     * be that an LTo cell or a Decoy cell, once surface adhesion time is complete
     * @param ppsim	The current simulation state
     * @return	the angle at which to move away from the cell which is currently in contact with this cell
     */
    public double avoidCellCollision(PPatchSim ppsim, double distanceToMove)
    {
    	boolean collide = true;
		int numAttempts = 10;			// flag to make sure that an infinite loop is not created if no position found
		double angle = 0.0;
		
		// now try to find a move for the given number of attempts
		for(int j=0;j<numAttempts && collide;j++)
		{
			// generate a random angle
			angle = Math.toRadians(ppsim.random.nextInt(360)+1);
			// work out where the cell would move to
			Double2D newPosition = calculateNewPosition(this.agentLocation,distanceToMove,angle,ppsim);
		
			try
			{
				// get the cells that would be in contact in this new position
				Class<?> environmentClass = ppsim.intestine_env.getClass();
				Method meth = environmentClass.getMethod("getObjectsExactlyWithinDistance",new Class[]{Double2D.class,double.class});
				Bag cellsInRange = (Bag)meth.invoke(ppsim.intestine_env,newPosition,ppsim.lookupDistance);
				//Bag cellsInRange = ppsim.intestine_env.tract.getObjectsExactlyWithinDistance(newPosition,ppsim.lookupDistance);
				
				// check whether the cell that was previously in contact is still in contact
				if(cellsInRange.contains(this.contactedCell))
				{
					collide = true;
				}
				else    // the new position is away from the cell
				{
					collide = false;	
				}
			}
			catch(Exception e)
			{
				e.printStackTrace();
			}
		}
		
		if(collide)
		{
			// a new position could not be found in the number of attempts given
			// just move away at a random angle (that may still result in some contact unfortunately)
			angle = Math.toRadians(ppsim.random.nextInt(360)+1);
		}
		
		// return the angle so the move can be made
		return angle;
    	
    	
    }
    
    /**
	 * Determines if a cell is in contact with any cell on the stroma (i.e. inactive & active LTo's, and decoy RET Ligand cells)
	 * @param tract	
	 * @param ppsim
	 * @return
	 */
	public boolean collisionCheck2(PPatchSim ppsim)
	{
		// 1 - Get all the cells that the LTin / LTi cell could hit
		//Bag cellsInRange = ppsim.intestine_env.tract.getObjectsExactlyWithinDistance(this.agentLocation,((simParams.HCELL_DIAMETER/2)+(simParams.LTO_DIAMETER/2)));
		// HACKED VERSION
		//Bag cellsInRange = ppsim.intestine_env.tract.getObjectsExactlyWithinDistance(this.agentLocation,ppsim.lookupDistance);
		
		Bag cellsInRange = null;
		
		try
		{
			Class<?> environmentClass = ppsim.intestine_env.getClass();
			Method meth = environmentClass.getMethod("getObjectsExactlyWithinDistance",new Class[]{Double2D.class,double.class});
			cellsInRange = (Bag)meth.invoke(ppsim.intestine_env,this.agentLocation,ppsim.lookupDistance);
			// 2 - GO THROUGH THE LIST IF NOT NULL
		}
		catch(Exception e)
		{
			e.printStackTrace();
		}
		
		boolean collision = false;		// flag to return if there is a collision
		
		if( cellsInRange != null )
		{
			// Now determine if there is contact with LTo cells
			// go through all potential clashes, avoiding itself
			for( int i = 0 ; i < cellsInRange.numObjs; i++ )
			{
				Object temp = cellsInRange.get(i);
				
			
				// check cell is not null or the cell is itself
				if(temp!=null && temp != this)
				{
					// check whether the cell is an immature LTo
					//if(temp instanceof LTo)
					if(temp.getClass().getName().equals("LTo"))
					{
						//LTo ltoCell = (LTo)temp;
						// Get the cell state of this LTo object
						try
						{
							Field contactedCellState = temp.getClass().getDeclaredField("cellState");
							Field contactedCellBindingProbability = temp.getClass().getDeclaredField("stableBindProbability");
							
							if(contactedCellState.getInt(temp)==0 && this.cellState==8)
							{
								// here, an LTi that has been in contact with an LTo is in contact with an immature cell
								// 	that it may activate (if within a certain distance). Call the method which increases
								// the contact count and activates the LTo if necessary
								//System.out.println("temp cell state 0");
								this.immatureLToActivation(ppsim,temp);
							}
							else if(contactedCellState.getInt(temp)>0 && contactedCellState.getInt(temp)!=9)
							{
								// NOW WORK OUT IF THIS CONTACT 'ACTIVATES' THE LTO
								// SIMULATES A 'BIND STRENGTH
								// 16/12/10
								// FIRSTLY NEED TO CHECK WHETHER THIS CONTACT CHANGES STATE (BASED ON A PROBABILITY)
								int probability = ppsim.random.nextInt(100)+1;
									
								if(probability<=contactedCellBindingProbability.getDouble(temp))	// the cell will move but remain in contact, held by vcam
								{
									// THE BIND HOLDS
									collision = true;
									
									// perform the art/ret signal & cell state change if required
									this.artnRETSignalling(ppsim);
									
									if(ppsim.simulationSpec.cellTrackingEnabled)
									{
										if(!ppsim.cellTrackStats.trackedCells_Close.contains(this))
										{
											ppsim.cellTrackStats.trackedCells_Away.remove(this);
											this.trackLength = 0;
											this.timeTracked = 0;
											this.agentTrackStartLocation = this.agentLocation;
											ppsim.cellTrackStats.trackedCells_Close.add(this);
										}
									}
									
									// stick the LTin/LTi to the LTo
									//if(simParams.oneStepAdhesion)
									//	this.adhesionTime = 2;
									//else
										//this.adhesionTime = 1;
								
									// store this as the cell the LTin is in contact with - will need this to calculate VCAM in next step
									this.contactedCell = temp;
									
									// DEAL WITH LTo SIGNALLING & STATE CHANGES IF NECESSARY CAUSED BY BIND
									this.updateLToState(this.contactedCell,(int)ppsim.schedule.getSteps());
									
								}
							}
						}
						catch(Exception e)
						{
							e.printStackTrace();
						}
					}
					// Now check if the cell is in contact with a decoy RET Ligand cell on the tract surface
					else if(temp.getClass().getName().equals("RLNonStromal"))
					{
						try
						{
							int probability = ppsim.random.nextInt(100)+1;
							Field contactedCellBindingProbability = temp.getClass().getDeclaredField("stableBindProbability");
							
							if(probability<=contactedCellBindingProbability.getDouble(temp))	// the cell will move but remain in contact, held by vcam
							{
								collision = true;
								// the cell will 'stick', so adjust the adhesion time & contact cell variables
								//if(simParams.oneStepAdhesion)
									//this.adhesionTime = 2;
								//else
									//this.adhesionTime = 1;
								
								this.contactedCell = temp;
							}
						}
						catch(Exception e)
						{
							e.printStackTrace();
						}
						
					}
				}
			}
		}
		return collision;
	}
	
	/**
	 * Updates the state of the stromal cell upon which the LTin/LTi cell is in stable contact
	 * 
	 * @param stromalCell	The stromal cell the LTin/LTi is in contact with
	 */
	public void updateLToState(Object stromalCell,int timeStep)
	{
		try
		{
			Class<?> stromalCellClass = stromalCell.getClass();
			Method upCount = stromalCellClass.getMethod("stableContact",new Class[]{Object.class,int.class});
			upCount.invoke(stromalCell,this,timeStep);
		}
		catch(Exception e)
		{
			e.printStackTrace();
		}
	}
	
	/**
     * Performs the interaction between RET and the RET Ligand on first interaction between a RET Ligand LTo and an LTin/LTi Cell
     */
    public void artnRETSignalling(PPatchSim ppsim)
	{
		if(this.cellState==4)   // LTin cell in initial state - with initial motion properties
		{
			// change state to show that ARTN/RET reaction has happened.
			this.cellState=5;                             // change cell colour to rep change in state
		}
	}
	
	/**
	 * Takes an Immature LTo cell which has been in contact with an LTi cell which has been in contact with an 'active' LTo 
	 * and determines if the contact count needs to be increased.  This is determined by distance from an active LTo.  The number 
	 * of contacts determines if the cell becomes active
	 * 
	 * @param ppsim	The current state of the simulation
	 * @param inactivelto	The cell to determine whether the contact count needs increasing
	 */
	public void immatureLToActivation(PPatchSim ppsim, Object inactivelto)
	{
		double closestLTo=100000.0;
		double distance = 0.0;
		
		try
		{
			// now go through each LTo and work out where the nearest active LTo is
			for(int l=0;l<ppsim.ltoCellsBag.size();l++)
			{
				Object ltoCell = ppsim.ltoCellsBag.get(l);
				
				Field ltoCellState = ltoCell.getClass().getDeclaredField("cellState");
				
				if(ltoCellState.getInt(ltoCell)>1)		// the LTo cell is active
				{
					// calculate the distance from this cell to the LTo
					// Need to get the location of the lto cell
					Double2D ltoLocation = (Double2D)ltoCell.getClass().getDeclaredField("agentLocation").get(ltoCell);
					// Get the location of the innactive LTo
					Double2D inactiveltoLocation = (Double2D)inactivelto.getClass().getDeclaredField("agentLocation").get(inactivelto);
					
					distance = (Math.sqrt((Math.pow(inactiveltoLocation.x-ltoLocation.x,2)+Math.pow(inactiveltoLocation.y-ltoLocation.y,2))));
					if(distance<closestLTo)
					{
						closestLTo = distance;
					}
				}	
			}
	
			// check whether the distance falls below the threshold set in the parameter list
			if(closestLTo<this.ltoDistanceThreshold)
			{
				Class<?> inactiveltoClass = inactivelto.getClass();
				Method upCount = inactiveltoClass.getMethod("incImLToCellContactCount",new Class[]{});
				upCount.invoke(inactivelto);
	
			}	
		}
		catch(Exception e)
		{
			e.printStackTrace();
		}
	}
	
	/**
	 * Detects collisions between LTin and LTi cells - important if LTin/LTi cells are also expressing RET ligands
	 * 
	 * @param tract	The simulation environment
	 * @return	Boolean stating whether there is contact with another LTin/LTi cell
	 */
	public boolean ltiltinCollision(Continuous2D tract)
	{
		Bag cellsInRange = tract.getObjectsExactlyWithinDistance(this.agentLocation,this.cell_diameter);
		
		if( cellsInRange != null )
		{
			// Now determine if there is contact with any other LTin/LTi cells
			// go through all potential clashes, avoiding itself
			for( int i = 0 ; i < cellsInRange.numObjs; i++ )
			{
				Object temp = cellsInRange.get(i);
			
				// check cell is not null or the cell is itself
				if(temp!=null && temp != this)
				{
					if(temp.getClass().getName().equals("LTin") || temp.getClass().getName().equals("LTi"))
					{
						// there has been a collision - now determine if the cell is a 'decoy' - expressing RET Ligand as 
						// an LTo is - if this is the case, the cell is assumed to have made contact for the surface adhesion step
						this.contactedCell = temp;
												
						return true;
					}
				}
			}
		}
		return false;
	}
			
	/**
	 * Used by the graphic console to draw the cell to the screen
	 */
	public final void draw(Object object, Graphics2D graphics, DrawInfo2D info)
    {
		// Note multiplied by info - this ensures the diameter grows as the zoom function is used
		double diamx = info.draw.width*this.cell_diameter;
		double diamy = info.draw.height*this.cell_diameter;
	
		graphics.setColor(PPatchSim.cellColours.get(cellState));
		Ellipse2D.Double cell = new Ellipse2D.Double((int)info.draw.x-diamx/2,(int)info.draw.y-diamy/2,(int)diamx,(int)diamy);
        graphics.fill(cell);
    }
}
